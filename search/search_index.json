{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to SU Tutor App Docs! \u00b6 This documentation outlines the user and developer guide.","title":"Home"},{"location":"#welcome-to-su-tutor-app-docs","text":"This documentation outlines the user and developer guide.","title":"Welcome to SU Tutor App Docs!"},{"location":"about/","text":"About \u00b6 Written by the following of the 2021 Computer Science Capstone at Southwestern University: Frontend Team \u00b6 Daniel Whitney: Whitney Whitehill Ethan Nunez: Backend Team \u00b6 Jake Gutierrez: Personal Website Dominic Blea Guy Greathouse The Project \u00b6 The SU Tutor App is a mobile app that assists Southwestern students in finding an official Southwestern tutor. Through the mobile app, students are able to search for and schedule sessions with specified tutors. Tutors are able to create a schedule through the Google Calendar API. Students are able to leave reviews about their tutors and vice-versa. To protect users of the app, a report function was added to report reviews and profiles of users. An admin interface (still in-development) is provided for administrators to specify tutors, create categories, follow up on reports, and more. There were two teams: frontend and backend. The frontend team was responsible for creating the mobile app in React-Native, a JavaScript library that is able to create apps for both Android and iOS. They were also responsible for interacting with the backend server to provide functionality to the app. The backend team was responsible for creating a REST API for the frontend to use and interact with both the database and Google Calendar API. The backend uses FastAPI, TortoiseORM, PostgreSQL, and Docker. The team utilized Kanban and Extreme Programming methods, specifically pair programming and code reviews. This purpose of this website is to provide accurate information to students, administrators, and developers about the project. Special Thanks \u00b6 We'd like to thank Southwestern University's Center for Academic Success for working with us on this project. We'd also like to thank our instructor and supervisor for this capstone project: Dr. Barbara Anthony. Copyright Information \u00b6 Copyright \u00a9 2021 by Southwestern University Computer Science 2021 Capstone All rights reserved. No part of this publication may be reproduced, distributed, or transmitted in any form or by any means, including photocopying, recording, or other electronic or mechanical methods, without the prior written permission of the publisher, except in the case of brief quotations embodied in critical reviews and certain other noncommercial uses permitted by copyright law.","title":"About"},{"location":"about/#about","text":"Written by the following of the 2021 Computer Science Capstone at Southwestern University:","title":"About"},{"location":"about/#frontend-team","text":"Daniel Whitney: Whitney Whitehill Ethan Nunez:","title":"Frontend Team"},{"location":"about/#backend-team","text":"Jake Gutierrez: Personal Website Dominic Blea Guy Greathouse","title":"Backend Team"},{"location":"about/#the-project","text":"The SU Tutor App is a mobile app that assists Southwestern students in finding an official Southwestern tutor. Through the mobile app, students are able to search for and schedule sessions with specified tutors. Tutors are able to create a schedule through the Google Calendar API. Students are able to leave reviews about their tutors and vice-versa. To protect users of the app, a report function was added to report reviews and profiles of users. An admin interface (still in-development) is provided for administrators to specify tutors, create categories, follow up on reports, and more. There were two teams: frontend and backend. The frontend team was responsible for creating the mobile app in React-Native, a JavaScript library that is able to create apps for both Android and iOS. They were also responsible for interacting with the backend server to provide functionality to the app. The backend team was responsible for creating a REST API for the frontend to use and interact with both the database and Google Calendar API. The backend uses FastAPI, TortoiseORM, PostgreSQL, and Docker. The team utilized Kanban and Extreme Programming methods, specifically pair programming and code reviews. This purpose of this website is to provide accurate information to students, administrators, and developers about the project.","title":"The Project"},{"location":"about/#special-thanks","text":"We'd like to thank Southwestern University's Center for Academic Success for working with us on this project. We'd also like to thank our instructor and supervisor for this capstone project: Dr. Barbara Anthony.","title":"Special Thanks"},{"location":"about/#copyright-information","text":"Copyright \u00a9 2021 by Southwestern University Computer Science 2021 Capstone All rights reserved. No part of this publication may be reproduced, distributed, or transmitted in any form or by any means, including photocopying, recording, or other electronic or mechanical methods, without the prior written permission of the publisher, except in the case of brief quotations embodied in critical reviews and certain other noncommercial uses permitted by copyright law.","title":"Copyright Information"},{"location":"developers/getting-started/","text":"Getting Started for Developers \u00b6 There are three components to the project: a frontend, a backend, and an admin interface. Frontend \u00b6 The frontend is a React Native application built with Expo. Introduction to the Frontend Backend \u00b6 The backend uses Docker Compose with two containers of the FastAPI server and the database. Introduction to the Backend Admin \u00b6 The admin interface uses React with React-Admin. The admin interface can be hosted on any platform that hosts static sites.","title":"Getting Started"},{"location":"developers/getting-started/#getting-started-for-developers","text":"There are three components to the project: a frontend, a backend, and an admin interface.","title":"Getting Started for Developers"},{"location":"developers/getting-started/#frontend","text":"The frontend is a React Native application built with Expo. Introduction to the Frontend","title":"Frontend"},{"location":"developers/getting-started/#backend","text":"The backend uses Docker Compose with two containers of the FastAPI server and the database. Introduction to the Backend","title":"Backend"},{"location":"developers/getting-started/#admin","text":"The admin interface uses React with React-Admin. The admin interface can be hosted on any platform that hosts static sites.","title":"Admin"},{"location":"developers/admin/introduction/","text":"Introduction to the Admin Interface \u00b6 The admin interface was created in React with React-Admin as a framework. The interface can be hosted anywhere that can host static HTML, CSS and JavaScript files. Netlify is the host of choice as it automatically builds the website whenever there is a push to the main branch of the GitHub repository and it handles redirects from Google authentication.","title":"Introduction"},{"location":"developers/admin/introduction/#introduction-to-the-admin-interface","text":"The admin interface was created in React with React-Admin as a framework. The interface can be hosted anywhere that can host static HTML, CSS and JavaScript files. Netlify is the host of choice as it automatically builds the website whenever there is a push to the main branch of the GitHub repository and it handles redirects from Google authentication.","title":"Introduction to the Admin Interface"},{"location":"developers/admin/setup/","text":"Setup \u00b6 Local Setup \u00b6 To setup the admin interface locally, you need to have Node.js installed. Look within the frontend developer guide to see how to do this. Next, clone the repository and run npm install in the root folder. This will install all of the necessary dependencies. Next, rename .env.example to .env. . This assumes that you have already setup the backend accordingly. Info You will need to add http://localhost:3000/login to the Google API account you setup in the backend developers guide. Start the backend, then run npm start in the root directory of the admin interface. Once it's started, navigate to http://localhost:3000 and try logging in with a valid Google account. Deployment \u00b6 For deployment, it is recommended to use Netlify as it handles redirects from Google that React Admin can understand. Before starting, you should fork the admin interface repository on GitHub. Then follow this guide on deploying a site from a GitHub repository and pause when you get to Step 5: https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/ . The admin interface's configuration is a bit different, under \"basic build settings\" ensure that the \"Build command\" is npm run build and the \"Publish directory\" is build . Click \"Show advanced\" and under \"Advanced build settings\" and two new variables: REACT_APP_BASE_URL and REACT_APP_REDIRECT_FULL_URL . The REACT_APP_BASE_URL should be the URL of your backend and REACT_APP_REDIRECT_FULL_URL will be the URL of your admin interface and then /login . You can edit these environment variables anytime in the \"Site Settings\" > \"Build & deploy\" > \"Environment\" section. Info Ensure that the REACT_APP_REDIRECT_FULL_URL is an Authorized Redirect URI in your Google API setup.","title":"Setup"},{"location":"developers/admin/setup/#setup","text":"","title":"Setup"},{"location":"developers/admin/setup/#local-setup","text":"To setup the admin interface locally, you need to have Node.js installed. Look within the frontend developer guide to see how to do this. Next, clone the repository and run npm install in the root folder. This will install all of the necessary dependencies. Next, rename .env.example to .env. . This assumes that you have already setup the backend accordingly. Info You will need to add http://localhost:3000/login to the Google API account you setup in the backend developers guide. Start the backend, then run npm start in the root directory of the admin interface. Once it's started, navigate to http://localhost:3000 and try logging in with a valid Google account.","title":"Local Setup"},{"location":"developers/admin/setup/#deployment","text":"For deployment, it is recommended to use Netlify as it handles redirects from Google that React Admin can understand. Before starting, you should fork the admin interface repository on GitHub. Then follow this guide on deploying a site from a GitHub repository and pause when you get to Step 5: https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/ . The admin interface's configuration is a bit different, under \"basic build settings\" ensure that the \"Build command\" is npm run build and the \"Publish directory\" is build . Click \"Show advanced\" and under \"Advanced build settings\" and two new variables: REACT_APP_BASE_URL and REACT_APP_REDIRECT_FULL_URL . The REACT_APP_BASE_URL should be the URL of your backend and REACT_APP_REDIRECT_FULL_URL will be the URL of your admin interface and then /login . You can edit these environment variables anytime in the \"Site Settings\" > \"Build & deploy\" > \"Environment\" section. Info Ensure that the REACT_APP_REDIRECT_FULL_URL is an Authorized Redirect URI in your Google API setup.","title":"Deployment"},{"location":"developers/backend/deployment/","text":"Deploying the Backend \u00b6 There are two main things needed to deploy the backend, a server to host the FastAPI application and a PostgreSQL database. Therefore, you can use any platform or service such as Heroku, Digital Ocean, AWS, GCP, private VPS, Azure, etc. There is a GitHub Actions workflow in .github/workflows/main.yml that will automate the process of building the production Dockerfile and deploy it to Google Cloud Run. This will be helpful to reference to as there are a series of commands that deploy it to Google Cloud Run. This guide will go through deploying the backend to Google Cloud Platform. Pushing Docker Imager to GCP \u00b6 First, we need to push the production docker image to GCP for Cloud Run to use. Download the gcloud CLI tool by following the directions here: https://cloud.google.com/sdk/docs/quickstart . Ensure that you selected the project that you used in the Google Setup when setting up Google API. Run the command gcloud auth configure-docker . Next, we need to establish where to push the built Docker image to. The URL format will be the following (will be referenced as <GCR_URL> ): gcr.io/<GCP_PROJECT_ID>/<CUSTOM_NAME>:latest Where <GCP_PROJECT_ID> will be your specific project ID and <CUSTOM_NAME> can be anything that you want such as \"backend\". Next, run the following command in the root directory of the backend. docker build \\ --tag <GCR_URL> \\ --file ./project/Dockerfile.prod \\ \"./project\" Wait for the Docker image to build and then run: docker push <GCR_URL> Now the production Docker image should be pushed to GCP, where we will see it when we setup Google Cloud Run. VPC Setup \u00b6 Before going into the database and backend setup, we need to create a Virtual Private Cloud network so that the Cloud Run instances can communicate to the database using a standard TCP connection with the database's private address that we will see later on. Go to the \"VPC network\" section (you may have to enable Compute Engine API) and go to the \"Serverless VPC access\" section (again, enabling the specific API). Once the specific API is enabled, click on the \"Create connector\" button. Give the VPC a name, set it to a region that is convenient. Select the \"Subnet\" to \"Custom IP range\", set the \"IP range\" to \"10.8.0.0\" and click on \"Create.\" Database Setup \u00b6 Go to the \"SQL\" section on GCP and click on \"Create instance\" (or similar) and choose PostgreSQL. Give the database instance a name, a password you can remember and an appropriate region. Info Cloud SQL databases can be costly, you can select a \"Lightweight\" database by going to \"Machine type\" under \"Customize your instance\" under the initial setup page. You can change this later. Click on \"Create\" and wait a while for the database instance to be created. Once it is created, go to the \"Connections\" section. Enable \"Private IP\" and select \"default\" as your network and then click \"Save\". Now that we have it all setup, we should take note of the new database URL that you will use later. On the \"Overview\" page take note of the \"Private IP\". The database URL will be in the following format: postgres://postgres:<password>@<private_ip>/postgres Cloud Run Setup \u00b6 Go to the GCP console and go to the Cloud Run section. Up at the top, click on \"Create service\". Give the service a name and leave the \"Deployment platform\" as is, but use the \"Region\" dropdown to select an ideal region. In the next step, select a container image using the \"Select\" button. You should find that there is a dropdown under the GCR URL you pushed the Docker image to in the previous step. Click on the dropdown and select the latest image. Stay in the same step and go into \"Advanced settings.\" Under \"Container\" > \"Capacity\", choose an appropriate size of RAM and CPUs, but it will fine if you leave it as it is. Under \"Container\" > \"Autoscaling\", leaving the \"Minimum\" at 0 will cause the server to have a long start up time, change this to 1 if you want to have a server running at all times. Under the \"Variables\" tab, you want to add every variable you have in your local .env file. Fill out the variable name and its value appropriately. You will want to change your DATABASE_URL to the one above in Cloud SQL setup. Under the \"Connections\" tab, under \"VPC Connector\", select the connector as \"default\". In the next step, leave \"Ingress\" as is and set the \"Authentication\" to \"Allow unauthenticated ...\" and click on create. Once you the service is setup completely, you should see a \"URL\" near the name of the service. Go to the /docs of that URL and see if it is running. Info Remember to add the URL to the Google OAuth API","title":"Deploying the Backend"},{"location":"developers/backend/deployment/#deploying-the-backend","text":"There are two main things needed to deploy the backend, a server to host the FastAPI application and a PostgreSQL database. Therefore, you can use any platform or service such as Heroku, Digital Ocean, AWS, GCP, private VPS, Azure, etc. There is a GitHub Actions workflow in .github/workflows/main.yml that will automate the process of building the production Dockerfile and deploy it to Google Cloud Run. This will be helpful to reference to as there are a series of commands that deploy it to Google Cloud Run. This guide will go through deploying the backend to Google Cloud Platform.","title":"Deploying the Backend"},{"location":"developers/backend/deployment/#pushing-docker-imager-to-gcp","text":"First, we need to push the production docker image to GCP for Cloud Run to use. Download the gcloud CLI tool by following the directions here: https://cloud.google.com/sdk/docs/quickstart . Ensure that you selected the project that you used in the Google Setup when setting up Google API. Run the command gcloud auth configure-docker . Next, we need to establish where to push the built Docker image to. The URL format will be the following (will be referenced as <GCR_URL> ): gcr.io/<GCP_PROJECT_ID>/<CUSTOM_NAME>:latest Where <GCP_PROJECT_ID> will be your specific project ID and <CUSTOM_NAME> can be anything that you want such as \"backend\". Next, run the following command in the root directory of the backend. docker build \\ --tag <GCR_URL> \\ --file ./project/Dockerfile.prod \\ \"./project\" Wait for the Docker image to build and then run: docker push <GCR_URL> Now the production Docker image should be pushed to GCP, where we will see it when we setup Google Cloud Run.","title":"Pushing Docker Imager to GCP"},{"location":"developers/backend/deployment/#vpc-setup","text":"Before going into the database and backend setup, we need to create a Virtual Private Cloud network so that the Cloud Run instances can communicate to the database using a standard TCP connection with the database's private address that we will see later on. Go to the \"VPC network\" section (you may have to enable Compute Engine API) and go to the \"Serverless VPC access\" section (again, enabling the specific API). Once the specific API is enabled, click on the \"Create connector\" button. Give the VPC a name, set it to a region that is convenient. Select the \"Subnet\" to \"Custom IP range\", set the \"IP range\" to \"10.8.0.0\" and click on \"Create.\"","title":"VPC Setup"},{"location":"developers/backend/deployment/#database-setup","text":"Go to the \"SQL\" section on GCP and click on \"Create instance\" (or similar) and choose PostgreSQL. Give the database instance a name, a password you can remember and an appropriate region. Info Cloud SQL databases can be costly, you can select a \"Lightweight\" database by going to \"Machine type\" under \"Customize your instance\" under the initial setup page. You can change this later. Click on \"Create\" and wait a while for the database instance to be created. Once it is created, go to the \"Connections\" section. Enable \"Private IP\" and select \"default\" as your network and then click \"Save\". Now that we have it all setup, we should take note of the new database URL that you will use later. On the \"Overview\" page take note of the \"Private IP\". The database URL will be in the following format: postgres://postgres:<password>@<private_ip>/postgres","title":"Database Setup"},{"location":"developers/backend/deployment/#cloud-run-setup","text":"Go to the GCP console and go to the Cloud Run section. Up at the top, click on \"Create service\". Give the service a name and leave the \"Deployment platform\" as is, but use the \"Region\" dropdown to select an ideal region. In the next step, select a container image using the \"Select\" button. You should find that there is a dropdown under the GCR URL you pushed the Docker image to in the previous step. Click on the dropdown and select the latest image. Stay in the same step and go into \"Advanced settings.\" Under \"Container\" > \"Capacity\", choose an appropriate size of RAM and CPUs, but it will fine if you leave it as it is. Under \"Container\" > \"Autoscaling\", leaving the \"Minimum\" at 0 will cause the server to have a long start up time, change this to 1 if you want to have a server running at all times. Under the \"Variables\" tab, you want to add every variable you have in your local .env file. Fill out the variable name and its value appropriately. You will want to change your DATABASE_URL to the one above in Cloud SQL setup. Under the \"Connections\" tab, under \"VPC Connector\", select the connector as \"default\". In the next step, leave \"Ingress\" as is and set the \"Authentication\" to \"Allow unauthenticated ...\" and click on create. Once you the service is setup completely, you should see a \"URL\" near the name of the service. Go to the /docs of that URL and see if it is running. Info Remember to add the URL to the Google OAuth API","title":"Cloud Run Setup"},{"location":"developers/backend/google-setup/","text":"Google Setup \u00b6 Before going in-depth about setting up the backend project, we need to setup the Google API service and get specific credentials that will be added to an .env file. Initial Setup \u00b6 You can use an existing project, or a new project, on Google Cloud Platform. Take note of the \"Project ID\" on the Dashboard page. Setting Up OAuth2 \u00b6 Under APIs & Services, go to the OAuth consent screen section and follow the steps to create an \"External\" application. Getting Credentials \u00b6 Go to the \"Credentials\" section. Near the top, click on \"Create Credentials\" and then on \"OAuth Client ID\". In the form, select the \"Application Type\" as \"Web application\" and then give it a nice name. For \"Authorized JavaScript Origins\", you don't need to add anything here. Under \"Authorized redirect URIs\", add the URI http://localhost:8080/auth/callback and http://localhost:8080/auth/swap . You can add to these later on. Once you click \"Create\", there will be a pop up with the Client ID and Secret, take note of both. Adding API Libraries \u00b6 We need to add specific APIs so we can access them. Go to the \"Library\" section and search for \"Google Calendar API\", click on the one that matches and click \"ENABLE\". Next Steps \u00b6 This is the minimal setup for Google Cloud Platform, we will touch on Cloud Run and Cloud SQL later on. By now, you should have the following information: Your Google project ID Google Client ID Google Client Secret List of Redirect URIs List of JavaScript origins (which is empty)","title":"Google Setup"},{"location":"developers/backend/google-setup/#google-setup","text":"Before going in-depth about setting up the backend project, we need to setup the Google API service and get specific credentials that will be added to an .env file.","title":"Google Setup"},{"location":"developers/backend/google-setup/#initial-setup","text":"You can use an existing project, or a new project, on Google Cloud Platform. Take note of the \"Project ID\" on the Dashboard page.","title":"Initial Setup"},{"location":"developers/backend/google-setup/#setting-up-oauth2","text":"Under APIs & Services, go to the OAuth consent screen section and follow the steps to create an \"External\" application.","title":"Setting Up OAuth2"},{"location":"developers/backend/google-setup/#getting-credentials","text":"Go to the \"Credentials\" section. Near the top, click on \"Create Credentials\" and then on \"OAuth Client ID\". In the form, select the \"Application Type\" as \"Web application\" and then give it a nice name. For \"Authorized JavaScript Origins\", you don't need to add anything here. Under \"Authorized redirect URIs\", add the URI http://localhost:8080/auth/callback and http://localhost:8080/auth/swap . You can add to these later on. Once you click \"Create\", there will be a pop up with the Client ID and Secret, take note of both.","title":"Getting Credentials"},{"location":"developers/backend/google-setup/#adding-api-libraries","text":"We need to add specific APIs so we can access them. Go to the \"Library\" section and search for \"Google Calendar API\", click on the one that matches and click \"ENABLE\".","title":"Adding API Libraries"},{"location":"developers/backend/google-setup/#next-steps","text":"This is the minimal setup for Google Cloud Platform, we will touch on Cloud Run and Cloud SQL later on. By now, you should have the following information: Your Google project ID Google Client ID Google Client Secret List of Redirect URIs List of JavaScript origins (which is empty)","title":"Next Steps"},{"location":"developers/backend/introduction/","text":"Introduction to the Backend \u00b6 Development \u00b6 There are multiple parts to the backend, mainly the FastAPI server and PostgreSQL database. FastAPI utilizes TortoiseORM to interact with the database. Docker was used to easily develop the application. FastAPI \u00b6 FastAPI is an asynchronous, Python web framework. It provides various tools to develop RESTful APIs in a timely manner. For example, it provides serialization, deserialization, and a specific /docs route that lists all of the method and endpoints available for the frontend to refer to. TortoiseORM \u00b6 TortoiseORM queries and manages the PostgreSQL database. It's compatible with MySQL and SQLite as well, but Postgres is just better. PostgreSQL \u00b6 PostgreSQL is not a strict requirement. However, TortoiseORM (paired with aerich) generates migrations files, which are a series of SQL commands, to set up the database. These migration files are specific to PostgreSQL. Docker \u00b6 Docker with Docker Compose was used to ease development of this project. Docker allows the creation of containers which are parts of an application. In this project, there was a Docker container for the FastAPI server and one for Cloud SQL Proxy. There are able to connect with each other through a Docker specific network. While the server and database were in separate containers, they were able to communicate as if they were on the same exact machine. Google Calendar API \u00b6 The Google Calendar API was used to get a tutor's schedule and add attendees to a specific event. To achieve this, we have each user log in with their Google accounts through OAuth2, and ask permission to read and update their calendar. Deployment \u00b6 For this project, we used Google Cloud Platform's Cloud Run and Cloud SQL. Cloud Run \u00b6 Cloud Run allows a Docker image to be deployed. This allows Cloud Run to easily make more instances of an application and balance requests between them. This is cost efficient as you only pay for what you use. We could use other services with GCP such as App Engine, but that stays on 24/7 whereas Cloud Run can shut down instances as the load decreases. Info You can use any server that supports Docker to host the backend server. But the instructions here will be specific to Cloud Run. Cloud SQL \u00b6 Since we were using GCP with free credits, we decided to use Cloud SQL for our PostgreSQL server.","title":"Introduction"},{"location":"developers/backend/introduction/#introduction-to-the-backend","text":"","title":"Introduction to the Backend"},{"location":"developers/backend/introduction/#development","text":"There are multiple parts to the backend, mainly the FastAPI server and PostgreSQL database. FastAPI utilizes TortoiseORM to interact with the database. Docker was used to easily develop the application.","title":"Development"},{"location":"developers/backend/introduction/#fastapi","text":"FastAPI is an asynchronous, Python web framework. It provides various tools to develop RESTful APIs in a timely manner. For example, it provides serialization, deserialization, and a specific /docs route that lists all of the method and endpoints available for the frontend to refer to.","title":"FastAPI"},{"location":"developers/backend/introduction/#tortoiseorm","text":"TortoiseORM queries and manages the PostgreSQL database. It's compatible with MySQL and SQLite as well, but Postgres is just better.","title":"TortoiseORM"},{"location":"developers/backend/introduction/#postgresql","text":"PostgreSQL is not a strict requirement. However, TortoiseORM (paired with aerich) generates migrations files, which are a series of SQL commands, to set up the database. These migration files are specific to PostgreSQL.","title":"PostgreSQL"},{"location":"developers/backend/introduction/#docker","text":"Docker with Docker Compose was used to ease development of this project. Docker allows the creation of containers which are parts of an application. In this project, there was a Docker container for the FastAPI server and one for Cloud SQL Proxy. There are able to connect with each other through a Docker specific network. While the server and database were in separate containers, they were able to communicate as if they were on the same exact machine.","title":"Docker"},{"location":"developers/backend/introduction/#google-calendar-api","text":"The Google Calendar API was used to get a tutor's schedule and add attendees to a specific event. To achieve this, we have each user log in with their Google accounts through OAuth2, and ask permission to read and update their calendar.","title":"Google Calendar API"},{"location":"developers/backend/introduction/#deployment","text":"For this project, we used Google Cloud Platform's Cloud Run and Cloud SQL.","title":"Deployment"},{"location":"developers/backend/introduction/#cloud-run","text":"Cloud Run allows a Docker image to be deployed. This allows Cloud Run to easily make more instances of an application and balance requests between them. This is cost efficient as you only pay for what you use. We could use other services with GCP such as App Engine, but that stays on 24/7 whereas Cloud Run can shut down instances as the load decreases. Info You can use any server that supports Docker to host the backend server. But the instructions here will be specific to Cloud Run.","title":"Cloud Run"},{"location":"developers/backend/introduction/#cloud-sql","text":"Since we were using GCP with free credits, we decided to use Cloud SQL for our PostgreSQL server.","title":"Cloud SQL"},{"location":"developers/backend/local-setup/","text":"Local Setup \u00b6 Now on to actually setting up the backend project for local development. Docker \u00b6 Docker with Docker Compose is used to easily develop as we can launch our services with one command. Follow the instructions to download Docker here: https://docs.docker.com/get-docker/ Verify you have Docker and Docker Compose installed by running: docker --version docker-compose --version Configuration \u00b6 Before starting the services, we need to configure environment variables and our database. Database Setup \u00b6 There are a couple of options that you could personally use to setup a database. Two ways implemented in this project are Cloud SQL Proxy and a standard PostgreSQL database, both described in the docker-compose.yml file. Cloud SQL \u00b6 To setup Cloud SQL, you first need to setup a database on GCP and create service credentials that access it. Follow instructions to setup the database here: https://cloud.google.com/sql/docs/postgres/quickstart Create a database called tutorappdev Next create a service account by following these instructions: https://cloud.google.com/sql/docs/mysql/connect-admin-proxy#create-service-account Info You can just follow the \"Create a Service Account\" instructions Move the private key file to the root directory of the project, at the same level as the docker-compose.yml file, and rename it to tutorappcreds.json . In docker-compose.yml , go to the cloud-sql-proxy section and look at the command. Change the -instances... to the following format based on your project ID, database ID and database location: -instances=<project ID>:<location>:<database ID>=tcp:0.0.0.0:5432 . Local Database \u00b6 If you would like to run the database as a normal PostgreSQL database, you can easily switch from the proxy to local. In docker-compose.yml , you can comment out the cloud-sql-proxy by putting # at the beginning of each line. Then uncomment the web-db section, ensuring that each section is aligned appropriately. Environment Variables \u00b6 To configure the project, we need .env file in the same directory as the docker-compose.yml file. So create a new file and paste in the following: GOOGLE_CLIENT_ID= GOOGLE_PROJECT_ID= GOOGLE_CLIENT_SECRET= GOOGLE_REDIRECT_URIS= GOOGLE_JS_ORIGINS= TOP_DOMAIN=\"southwestern.edu\" DATABASE_URL= Fill out each variable appropriately, with most of the information obtained from the Google setup. The URIs are expected to be an array so fill out the URIs and Origins like so: GOOGLE_REDIRECT_URIS=[\"http://localhost:8080/auth/callback\",\"http://localhost:8080/auth/swap\"] GOOGLE_JS_ORIGINS=[] The TOP_DOMAIN variable only allows users of that domain to access Tutor App. For instance, if we had the email: john@southwestern.edu then that email will be allowed to log in with Google. The DATABASE_URL varies based on the database process you followed, however it has the general format: postgres://<username>:<password>@<ip address>:5432/<database> If you followed the Cloud SQL Proxy fill it out like so: postgres://<username>:<password>@cloud-sql-proxy:5432/tutorappdev Otherwise with the Local Setup: postgres://postgres:postgres@web-db:5432/postgres Starting the Project \u00b6 To run the project use the following command: docker-compose up --build This will build the containers by downloading necessary components and start the FastAPI and database container. Once you build once, you don't have to build again so you can instead run: docker-compose up","title":"Local Setup"},{"location":"developers/backend/local-setup/#local-setup","text":"Now on to actually setting up the backend project for local development.","title":"Local Setup"},{"location":"developers/backend/local-setup/#docker","text":"Docker with Docker Compose is used to easily develop as we can launch our services with one command. Follow the instructions to download Docker here: https://docs.docker.com/get-docker/ Verify you have Docker and Docker Compose installed by running: docker --version docker-compose --version","title":"Docker"},{"location":"developers/backend/local-setup/#configuration","text":"Before starting the services, we need to configure environment variables and our database.","title":"Configuration"},{"location":"developers/backend/local-setup/#database-setup","text":"There are a couple of options that you could personally use to setup a database. Two ways implemented in this project are Cloud SQL Proxy and a standard PostgreSQL database, both described in the docker-compose.yml file.","title":"Database Setup"},{"location":"developers/backend/local-setup/#cloud-sql","text":"To setup Cloud SQL, you first need to setup a database on GCP and create service credentials that access it. Follow instructions to setup the database here: https://cloud.google.com/sql/docs/postgres/quickstart Create a database called tutorappdev Next create a service account by following these instructions: https://cloud.google.com/sql/docs/mysql/connect-admin-proxy#create-service-account Info You can just follow the \"Create a Service Account\" instructions Move the private key file to the root directory of the project, at the same level as the docker-compose.yml file, and rename it to tutorappcreds.json . In docker-compose.yml , go to the cloud-sql-proxy section and look at the command. Change the -instances... to the following format based on your project ID, database ID and database location: -instances=<project ID>:<location>:<database ID>=tcp:0.0.0.0:5432 .","title":"Cloud SQL"},{"location":"developers/backend/local-setup/#local-database","text":"If you would like to run the database as a normal PostgreSQL database, you can easily switch from the proxy to local. In docker-compose.yml , you can comment out the cloud-sql-proxy by putting # at the beginning of each line. Then uncomment the web-db section, ensuring that each section is aligned appropriately.","title":"Local Database"},{"location":"developers/backend/local-setup/#environment-variables","text":"To configure the project, we need .env file in the same directory as the docker-compose.yml file. So create a new file and paste in the following: GOOGLE_CLIENT_ID= GOOGLE_PROJECT_ID= GOOGLE_CLIENT_SECRET= GOOGLE_REDIRECT_URIS= GOOGLE_JS_ORIGINS= TOP_DOMAIN=\"southwestern.edu\" DATABASE_URL= Fill out each variable appropriately, with most of the information obtained from the Google setup. The URIs are expected to be an array so fill out the URIs and Origins like so: GOOGLE_REDIRECT_URIS=[\"http://localhost:8080/auth/callback\",\"http://localhost:8080/auth/swap\"] GOOGLE_JS_ORIGINS=[] The TOP_DOMAIN variable only allows users of that domain to access Tutor App. For instance, if we had the email: john@southwestern.edu then that email will be allowed to log in with Google. The DATABASE_URL varies based on the database process you followed, however it has the general format: postgres://<username>:<password>@<ip address>:5432/<database> If you followed the Cloud SQL Proxy fill it out like so: postgres://<username>:<password>@cloud-sql-proxy:5432/tutorappdev Otherwise with the Local Setup: postgres://postgres:postgres@web-db:5432/postgres","title":"Environment Variables"},{"location":"developers/backend/local-setup/#starting-the-project","text":"To run the project use the following command: docker-compose up --build This will build the containers by downloading necessary components and start the FastAPI and database container. Once you build once, you don't have to build again so you can instead run: docker-compose up","title":"Starting the Project"},{"location":"developers/backend/structure/","text":"Structure of the Backend \u00b6 TutorAppBackend/ \u251c\u2500\u2500 .github/ \u2502 \u2514\u2500\u2500 workflows/ \u2502 \u251c\u2500\u2500 main.yml \u2502 \u2514\u2500\u2500 pl.yml \u251c\u2500\u2500 project/ \u2502 \u251c\u2500\u2500 app/ \u2502 \u2502 \u251c\u2500\u2500 api/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 <various python files> \u2502 \u2502 \u2502 \u2514\u2500\u2500 <create new routes in this folder> \u2502 \u2502 \u251c\u2500\u2500 migrations/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 models/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 <various SQL files> \u2502 \u2502 \u251c\u2500\u2500 models/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 pydnatic.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 tortoise.py -- Define new models for TortoiseORM \u2502 \u2502 \u2502 \u2514\u2500\u2500 utils.py \u2502 \u2502 \u251c\u2500\u2500 config.py -- Other configuration shouldn't need \u2502 \u2502 \u251c\u2500\u2500 db.py -- configure database connection \u2502 \u2502 \u2514\u2500\u2500 main.py -- Setup routes and extensions, and start \u2502 \u251c\u2500\u2500 db/ \u2502 \u2502 \u2514\u2500\u2500 <files for local database development> \u2502 \u251c\u2500\u2500 .coverage \u2502 \u251c\u2500\u2500 .coveragerc \u2502 \u251c\u2500\u2500 .dockerignore \u2502 \u251c\u2500\u2500 .flake8 \u2502 \u251c\u2500\u2500 .isort.cfg \u2502 \u251c\u2500\u2500 aerich.ini \u2502 \u251c\u2500\u2500 Dockerfile -- Dockerfile for local development \u2502 \u251c\u2500\u2500 Dockerfile.prod -- Dockerfile for production, build and push to another registry \u2502 \u251c\u2500\u2500 entrypoint.sh \u2502 \u251c\u2500\u2500 rquirements.txt \u2502 \u2514\u2500\u2500 setup.cfg \u251c\u2500\u2500 .env \u251c\u2500\u2500 docker-compose.yml \u2514\u2500\u2500 tutorappcreds.json -- If using Cloud SQL Proxy","title":"Structure"},{"location":"developers/backend/structure/#structure-of-the-backend","text":"TutorAppBackend/ \u251c\u2500\u2500 .github/ \u2502 \u2514\u2500\u2500 workflows/ \u2502 \u251c\u2500\u2500 main.yml \u2502 \u2514\u2500\u2500 pl.yml \u251c\u2500\u2500 project/ \u2502 \u251c\u2500\u2500 app/ \u2502 \u2502 \u251c\u2500\u2500 api/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 <various python files> \u2502 \u2502 \u2502 \u2514\u2500\u2500 <create new routes in this folder> \u2502 \u2502 \u251c\u2500\u2500 migrations/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 models/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 <various SQL files> \u2502 \u2502 \u251c\u2500\u2500 models/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 pydnatic.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 tortoise.py -- Define new models for TortoiseORM \u2502 \u2502 \u2502 \u2514\u2500\u2500 utils.py \u2502 \u2502 \u251c\u2500\u2500 config.py -- Other configuration shouldn't need \u2502 \u2502 \u251c\u2500\u2500 db.py -- configure database connection \u2502 \u2502 \u2514\u2500\u2500 main.py -- Setup routes and extensions, and start \u2502 \u251c\u2500\u2500 db/ \u2502 \u2502 \u2514\u2500\u2500 <files for local database development> \u2502 \u251c\u2500\u2500 .coverage \u2502 \u251c\u2500\u2500 .coveragerc \u2502 \u251c\u2500\u2500 .dockerignore \u2502 \u251c\u2500\u2500 .flake8 \u2502 \u251c\u2500\u2500 .isort.cfg \u2502 \u251c\u2500\u2500 aerich.ini \u2502 \u251c\u2500\u2500 Dockerfile -- Dockerfile for local development \u2502 \u251c\u2500\u2500 Dockerfile.prod -- Dockerfile for production, build and push to another registry \u2502 \u251c\u2500\u2500 entrypoint.sh \u2502 \u251c\u2500\u2500 rquirements.txt \u2502 \u2514\u2500\u2500 setup.cfg \u251c\u2500\u2500 .env \u251c\u2500\u2500 docker-compose.yml \u2514\u2500\u2500 tutorappcreds.json -- If using Cloud SQL Proxy","title":"Structure of the Backend"},{"location":"developers/backend/using-docs/","text":"Using the Docs \u00b6 One of the many benefits of FastAPI is that it generates documentation based on the added routes. Once you have your local docker containers running, you can go to http://localhost:8080/docs to view the documentation. Testing Google \u00b6 To test your Google setup. Go to http://localhost:8080/auth/code/client in your browser. A familiar Google sign-in page will appear, select a valid Google account (one ending in the same TOP_DOMAIN variable configured earlier). Accept the permissions and you should be taken to a screen where your specific user information should be. If there is very little information, such as {\"details\": \"<info here>\"} that means something is not correct and you may need to double-check your Google credentials. Example Use of Docs \u00b6 To test any of the routes, click on the route you would like to test. For instance, click on the /ping route and a drop down will appear with more information about that route. The documentation will let you know if there are any query parameters needed or if the request expects a body. Clicking on Try it out will allow you to fill out the necessary information. Once you filled out any information click on Execute and the website will let you know the server's response. Authorizing the Docs \u00b6 You might notice locks around certain routes. These locks indicate that the route is protected and needs authorization information to be used. To use the protected routes in the documentation, go back to http://localhost:8080/auth/code/client in your browser. Once you log in, take note of the access_token that is a part of the JSON response. This access token is used in the headers of your request, where you can set the Authorize header to Bearer <access_token> . The documentation website takes care of this. Near the top of the page, there is a green Authorize button. Click on that and fill out the Value box with the access token from http://localhost:8080/auth/code/client . Click on Authorize and then Close will let you access the protected routes. To verify that your access token is correct, go to the /user/me route try it out. The response should be your specific user information. Wrapping Up \u00b6 Now that you have your docs authorized, you're now able to use any of the routes (except ones requiring a superuser permission).","title":"Using the Docs"},{"location":"developers/backend/using-docs/#using-the-docs","text":"One of the many benefits of FastAPI is that it generates documentation based on the added routes. Once you have your local docker containers running, you can go to http://localhost:8080/docs to view the documentation.","title":"Using the Docs"},{"location":"developers/backend/using-docs/#testing-google","text":"To test your Google setup. Go to http://localhost:8080/auth/code/client in your browser. A familiar Google sign-in page will appear, select a valid Google account (one ending in the same TOP_DOMAIN variable configured earlier). Accept the permissions and you should be taken to a screen where your specific user information should be. If there is very little information, such as {\"details\": \"<info here>\"} that means something is not correct and you may need to double-check your Google credentials.","title":"Testing Google"},{"location":"developers/backend/using-docs/#example-use-of-docs","text":"To test any of the routes, click on the route you would like to test. For instance, click on the /ping route and a drop down will appear with more information about that route. The documentation will let you know if there are any query parameters needed or if the request expects a body. Clicking on Try it out will allow you to fill out the necessary information. Once you filled out any information click on Execute and the website will let you know the server's response.","title":"Example Use of Docs"},{"location":"developers/backend/using-docs/#authorizing-the-docs","text":"You might notice locks around certain routes. These locks indicate that the route is protected and needs authorization information to be used. To use the protected routes in the documentation, go back to http://localhost:8080/auth/code/client in your browser. Once you log in, take note of the access_token that is a part of the JSON response. This access token is used in the headers of your request, where you can set the Authorize header to Bearer <access_token> . The documentation website takes care of this. Near the top of the page, there is a green Authorize button. Click on that and fill out the Value box with the access token from http://localhost:8080/auth/code/client . Click on Authorize and then Close will let you access the protected routes. To verify that your access token is correct, go to the /user/me route try it out. The response should be your specific user information.","title":"Authorizing the Docs"},{"location":"developers/backend/using-docs/#wrapping-up","text":"Now that you have your docs authorized, you're now able to use any of the routes (except ones requiring a superuser permission).","title":"Wrapping Up"},{"location":"developers/backend/using-google/","text":"Using Google \u00b6 An important aspect of the project is the scheduling of users with tutors, we utilize the Google API in a couple of different ways. Authentication \u00b6 We require users to log in with their Google account in order to get their credentials (API specific credentials, not a password) and get permission to view and update their calendars and events. Creating and Getting Schedules \u00b6 Whenever a user becomes a tutor (specifics in Admin section), the backend creates a calendar for them named \"TutorApp Schedule\". In this calendar they can setup blocks of time they are available to tutor, along with a location that can be physical or virtual. Whenever a user wants to schedule, we query the Google Calendar API to get the events of the specific \"TutorApp Schedule\" calendar. When the user schedules, we use the same API to add them as an attendee to the event they schedule for.","title":"Using Google"},{"location":"developers/backend/using-google/#using-google","text":"An important aspect of the project is the scheduling of users with tutors, we utilize the Google API in a couple of different ways.","title":"Using Google"},{"location":"developers/backend/using-google/#authentication","text":"We require users to log in with their Google account in order to get their credentials (API specific credentials, not a password) and get permission to view and update their calendars and events.","title":"Authentication"},{"location":"developers/backend/using-google/#creating-and-getting-schedules","text":"Whenever a user becomes a tutor (specifics in Admin section), the backend creates a calendar for them named \"TutorApp Schedule\". In this calendar they can setup blocks of time they are available to tutor, along with a location that can be physical or virtual. Whenever a user wants to schedule, we query the Google Calendar API to get the events of the specific \"TutorApp Schedule\" calendar. When the user schedules, we use the same API to add them as an attendee to the event they schedule for.","title":"Creating and Getting Schedules"},{"location":"developers/frontend/architecture/","text":"Architecture \u00b6 The project directory attempts to enforce an architecture of the applications. In the source directory, there is a filed named app.js . This file is the root file that acts as the entry point for the application. Another layer deeper and we get to the auxiliary files used to support the view, functionality, and reusability of components of the application. Components \u00b6 One of the benefits of using React and React Native is the compartmentalization of various components. As a result, the folder /src/components contains all of the reusable UI components. It's important in developing an application like this to modularize the UI components so that they can be reused and limit the complexity and size of the code base. Navigators \u00b6 Navigators are a necessary component of React Native and what are utilized to make decisions about how the user will flow through the application. As a result, these files have been placed in /src/navigators and the contain references to the their children which are screens. Screens \u00b6 A screen is the canvas that contains the UI elements along with presenting a user some functionality. All of the screens are in /src/screens and when adding new screens, this is where you would want to place those files. It's important to keep as much of the business of the application out of the screen which is where providers and components come together to flesh out the application Providers \u00b6 Providers are the business logic of the application. In this folder we have the global user provider which deals with the user state and allows different components access to that state. We also have all of the api functionality within the providers folder at /src/providers/ . This folder is part of enforcing that we remove as much of the business of the application out of the screens files to avoid the files growing so large in size that they become incomprehensible.","title":"Architecture"},{"location":"developers/frontend/architecture/#architecture","text":"The project directory attempts to enforce an architecture of the applications. In the source directory, there is a filed named app.js . This file is the root file that acts as the entry point for the application. Another layer deeper and we get to the auxiliary files used to support the view, functionality, and reusability of components of the application.","title":"Architecture"},{"location":"developers/frontend/architecture/#components","text":"One of the benefits of using React and React Native is the compartmentalization of various components. As a result, the folder /src/components contains all of the reusable UI components. It's important in developing an application like this to modularize the UI components so that they can be reused and limit the complexity and size of the code base.","title":"Components"},{"location":"developers/frontend/architecture/#navigators","text":"Navigators are a necessary component of React Native and what are utilized to make decisions about how the user will flow through the application. As a result, these files have been placed in /src/navigators and the contain references to the their children which are screens.","title":"Navigators"},{"location":"developers/frontend/architecture/#screens","text":"A screen is the canvas that contains the UI elements along with presenting a user some functionality. All of the screens are in /src/screens and when adding new screens, this is where you would want to place those files. It's important to keep as much of the business of the application out of the screen which is where providers and components come together to flesh out the application","title":"Screens"},{"location":"developers/frontend/architecture/#providers","text":"Providers are the business logic of the application. In this folder we have the global user provider which deals with the user state and allows different components access to that state. We also have all of the api functionality within the providers folder at /src/providers/ . This folder is part of enforcing that we remove as much of the business of the application out of the screens files to avoid the files growing so large in size that they become incomprehensible.","title":"Providers"},{"location":"developers/frontend/initial-downloads/","text":"Getting Started \u00b6 Introduction \u00b6 To get started with React Native, a few commands will be need to run on your machine's terminal. Begin by creating a new folder on your machine. Name the folder whatever you find appropriate, this will act as the project directory. Then open up your machine's terminal which will be used throughout the installation process. Download Node.js \u00b6 In order for this project to run correctly on your machine. You can view the download page in English on the Node website by going to the (Node.js website)[nodejs.org/en/download/`]. Here you will select the download package for your operating system (i.e. macOS or Windows). Once you select the correct package, open the download and you a window will pop up and walk you through the installation process. Download Expo \u00b6 Once Node.js is downloaded you will need to install Expo . Do this by changing directories to your machines root directory. Run the command cd .. in the terminal until you reach your machines root directory. Next, run the the command npm install -g expo-cli to install Expo. Once expo is downloaded, you can exit your project terminal. Downloading Project \u00b6 The easiest way to open the code for this application is to clone the repository using git. You can clone this project into the project directory you created earlier. You can clone the repository in your IDE, we recommend using Visual Studio code. Install Packages \u00b6 Now that you have node.js and the base requirements, open a terminal and navigate to though source directory. At that point, you can run the command npm install . This command will look through package.json file and download all the necessary packages to build the application. Run code \u00b6 To see the client side portion open the code in your IDE and open up a terminal and make sure you are in the project directory. Run the command npm install then npm run start in the project terminal. From here a window should pop up in your web browser. The page should contain a QR code. Before scanning the QR code make sure you download the app Expo Go which can be downloaded from the App Store and the Google Play Store. Expo Go will let you see any real changes that you make to the code in real time. Expo may require for you to create an account and log in in order to see the full functionality of the app and log in this can be done through the sign up page which will give provide more instructions on creating an Expo account.","title":"Getting Started"},{"location":"developers/frontend/initial-downloads/#getting-started","text":"","title":"Getting Started"},{"location":"developers/frontend/initial-downloads/#introduction","text":"To get started with React Native, a few commands will be need to run on your machine's terminal. Begin by creating a new folder on your machine. Name the folder whatever you find appropriate, this will act as the project directory. Then open up your machine's terminal which will be used throughout the installation process.","title":"Introduction"},{"location":"developers/frontend/initial-downloads/#download-nodejs","text":"In order for this project to run correctly on your machine. You can view the download page in English on the Node website by going to the (Node.js website)[nodejs.org/en/download/`]. Here you will select the download package for your operating system (i.e. macOS or Windows). Once you select the correct package, open the download and you a window will pop up and walk you through the installation process.","title":"Download Node.js"},{"location":"developers/frontend/initial-downloads/#download-expo","text":"Once Node.js is downloaded you will need to install Expo . Do this by changing directories to your machines root directory. Run the command cd .. in the terminal until you reach your machines root directory. Next, run the the command npm install -g expo-cli to install Expo. Once expo is downloaded, you can exit your project terminal.","title":"Download Expo"},{"location":"developers/frontend/initial-downloads/#downloading-project","text":"The easiest way to open the code for this application is to clone the repository using git. You can clone this project into the project directory you created earlier. You can clone the repository in your IDE, we recommend using Visual Studio code.","title":"Downloading Project"},{"location":"developers/frontend/initial-downloads/#install-packages","text":"Now that you have node.js and the base requirements, open a terminal and navigate to though source directory. At that point, you can run the command npm install . This command will look through package.json file and download all the necessary packages to build the application.","title":"Install Packages"},{"location":"developers/frontend/initial-downloads/#run-code","text":"To see the client side portion open the code in your IDE and open up a terminal and make sure you are in the project directory. Run the command npm install then npm run start in the project terminal. From here a window should pop up in your web browser. The page should contain a QR code. Before scanning the QR code make sure you download the app Expo Go which can be downloaded from the App Store and the Google Play Store. Expo Go will let you see any real changes that you make to the code in real time. Expo may require for you to create an account and log in in order to see the full functionality of the app and log in this can be done through the sign up page which will give provide more instructions on creating an Expo account.","title":"Run code"},{"location":"developers/frontend/introduction/","text":"Introduction to the Frontend \u00b6 Development \u00b6 The frontend is a hybrid mobile application. This means that when compiled, the application will run on both Android and iOS devices. More on how that is accomplished below. React Native \u00b6 React Native is a JavaScript library that is a port of the React framework. React Native is the base of the frontend and what allows us to build a mobile application that is cross platform. React Native translates what would traditionally be a web view into a mobile application. React \u00b6 React is a JavaScript library made by Facebook and a common framework used to develop UIs for its' state management and lightweight compiled applications. The frontend relies on React Hooks to manage screen/component state, like useState, useEffect, useContext, and useReducer. Expo \u00b6 Expo is a packager that allows us to focus solely on cross platform functionality and does a lot of the work in compiling React/React Native into separate native applications for iOS/Android.","title":"Introduction"},{"location":"developers/frontend/introduction/#introduction-to-the-frontend","text":"","title":"Introduction to the Frontend"},{"location":"developers/frontend/introduction/#development","text":"The frontend is a hybrid mobile application. This means that when compiled, the application will run on both Android and iOS devices. More on how that is accomplished below.","title":"Development"},{"location":"developers/frontend/introduction/#react-native","text":"React Native is a JavaScript library that is a port of the React framework. React Native is the base of the frontend and what allows us to build a mobile application that is cross platform. React Native translates what would traditionally be a web view into a mobile application.","title":"React Native"},{"location":"developers/frontend/introduction/#react","text":"React is a JavaScript library made by Facebook and a common framework used to develop UIs for its' state management and lightweight compiled applications. The frontend relies on React Hooks to manage screen/component state, like useState, useEffect, useContext, and useReducer.","title":"React"},{"location":"developers/frontend/introduction/#expo","text":"Expo is a packager that allows us to focus solely on cross platform functionality and does a lot of the work in compiling React/React Native into separate native applications for iOS/Android.","title":"Expo"},{"location":"developers/frontend/styling-guide/","text":"Styling Guide \u00b6 Main Focus \u00b6 Our main focus behind how we wanted this application to look was to make sure that it could be navigated through easily and was familiar to the our user base. We wanted the user interface to match that of popular social media applications that we felt our users used on a daily basis. Being that we are creating this application for Southwestern University, we wanted to make sure that we also abided by their Branding Guidelines . Background Photos \u00b6 All of the photos used in this application came from Southwestern's Campus Photos page on their website. These photos were taken by the students and faculty of Southwestern University. Colors \u00b6 The color scheme we used for this mobile application came from Southwestern's Color Palette . These are the school colors and being that we made this application for the University, we wanted the colors to match the school colors.","title":"Styling Guide"},{"location":"developers/frontend/styling-guide/#styling-guide","text":"","title":"Styling Guide"},{"location":"developers/frontend/styling-guide/#main-focus","text":"Our main focus behind how we wanted this application to look was to make sure that it could be navigated through easily and was familiar to the our user base. We wanted the user interface to match that of popular social media applications that we felt our users used on a daily basis. Being that we are creating this application for Southwestern University, we wanted to make sure that we also abided by their Branding Guidelines .","title":"Main Focus"},{"location":"developers/frontend/styling-guide/#background-photos","text":"All of the photos used in this application came from Southwestern's Campus Photos page on their website. These photos were taken by the students and faculty of Southwestern University.","title":"Background Photos"},{"location":"developers/frontend/styling-guide/#colors","text":"The color scheme we used for this mobile application came from Southwestern's Color Palette . These are the school colors and being that we made this application for the University, we wanted the colors to match the school colors.","title":"Colors"},{"location":"user/edit-profile/","text":"Edit Profile \u00b6 In this application, we wanted tutors to be able to add a little something about themselves so that students that are looking for tutors can read it before they decide if they want to go to that tutor. In your about me, we want you to put things like, your graduating year, your degree, what some of your interests are, etc. Guidlines to Follow \u00b6 When editing your about me, make sure to follow the Southwestern Universities Student Handbook . The Center For Academic Success has access to view all profile about me pages.","title":"Edit Profile"},{"location":"user/edit-profile/#edit-profile","text":"In this application, we wanted tutors to be able to add a little something about themselves so that students that are looking for tutors can read it before they decide if they want to go to that tutor. In your about me, we want you to put things like, your graduating year, your degree, what some of your interests are, etc.","title":"Edit Profile"},{"location":"user/edit-profile/#guidlines-to-follow","text":"When editing your about me, make sure to follow the Southwestern Universities Student Handbook . The Center For Academic Success has access to view all profile about me pages.","title":"Guidlines to Follow"},{"location":"user/getting-started/","text":"Getting Started for Users \u00b6 Installing the App \u00b6 To access SU Tutor, you must install the app from either the App Store or Google Play Store. Links will be provided to the respective stores once the apps have been deployed. Logging In \u00b6 Once you install the app, you can log-in through your Southwestern Google account. Begin by opening the app and you will be brought to the splash screen shown below. From the splash screen you click the Sign in with Google button which will then take you to the honor code screen. In order to proceed further into the app the terms and conditions laid out in the Honor Code. By clicking the Yes you will be directed to the Google log in. Once you have logged in you will be able to navigate the app. Warning You must use your Southwestern account to access the app. Home Screen \u00b6 Once you are logged in you will be brought to the home screen.Please note that the resources and links provided on the home screen are subject to change depending on what sources have been provided by Southwestern University and their associated departments that offer tutoring. From the home screen you can use the yellow navigation bar at the bottom of the page to navigate to a screen that will let you search for a tutor and your profile screen.","title":"Getting Started"},{"location":"user/getting-started/#getting-started-for-users","text":"","title":"Getting Started for Users"},{"location":"user/getting-started/#installing-the-app","text":"To access SU Tutor, you must install the app from either the App Store or Google Play Store. Links will be provided to the respective stores once the apps have been deployed.","title":"Installing the App"},{"location":"user/getting-started/#logging-in","text":"Once you install the app, you can log-in through your Southwestern Google account. Begin by opening the app and you will be brought to the splash screen shown below. From the splash screen you click the Sign in with Google button which will then take you to the honor code screen. In order to proceed further into the app the terms and conditions laid out in the Honor Code. By clicking the Yes you will be directed to the Google log in. Once you have logged in you will be able to navigate the app. Warning You must use your Southwestern account to access the app.","title":"Logging In"},{"location":"user/getting-started/#home-screen","text":"Once you are logged in you will be brought to the home screen.Please note that the resources and links provided on the home screen are subject to change depending on what sources have been provided by Southwestern University and their associated departments that offer tutoring. From the home screen you can use the yellow navigation bar at the bottom of the page to navigate to a screen that will let you search for a tutor and your profile screen.","title":"Home Screen"},{"location":"user/reporting/","text":"Reporting \u00b6 A core principal in this app is that Southwestern Students abide by the Student Handbook and treat other students with respect. This means that if a student decides to use any type of offensive language, they are subject to be reported and disciplined accordingly by Southwestern University. As a way to help monitor the app there are options for the user to choose in order to report students who are abiding by the Southwestern University Handbook and community guidelines. Reporting a User \u00b6 If a user has an inappropriate about me section there is a modal that will pop up that will allow the user to report an about me section for an inappropriate profile image, about me section, or for incorrect profile information. The user can select the issue accordingly and it will be reported to the university. When to Report a Review \u00b6 To help maintain the integrity of the app do not report low rated reviews unless they do not abide by the SU Student Handbook, this includes but not limited to racial slurs, curse words, and sexual language. The purpose of the app is to provide meaningful data to the university to better support the academic guides. Different students have different learning styles and what helps one for one student may not help another. By providing reviews about the tutoring session such as tutoring style, knowledge on the subject, etc. other users should be able to determine if a guide is suitable for their style of learning. Likewise, the students on the app should take careful consideration when reviewing their reviews. The purpose of the reviews is to provide constructive criticism or praise for a guide. Reviews that do not offer meaningful input on a tutoring session should be reported.","title":"Reporting"},{"location":"user/reporting/#reporting","text":"A core principal in this app is that Southwestern Students abide by the Student Handbook and treat other students with respect. This means that if a student decides to use any type of offensive language, they are subject to be reported and disciplined accordingly by Southwestern University. As a way to help monitor the app there are options for the user to choose in order to report students who are abiding by the Southwestern University Handbook and community guidelines.","title":"Reporting"},{"location":"user/reporting/#reporting-a-user","text":"If a user has an inappropriate about me section there is a modal that will pop up that will allow the user to report an about me section for an inappropriate profile image, about me section, or for incorrect profile information. The user can select the issue accordingly and it will be reported to the university.","title":"Reporting a User"},{"location":"user/reporting/#when-to-report-a-review","text":"To help maintain the integrity of the app do not report low rated reviews unless they do not abide by the SU Student Handbook, this includes but not limited to racial slurs, curse words, and sexual language. The purpose of the app is to provide meaningful data to the university to better support the academic guides. Different students have different learning styles and what helps one for one student may not help another. By providing reviews about the tutoring session such as tutoring style, knowledge on the subject, etc. other users should be able to determine if a guide is suitable for their style of learning. Likewise, the students on the app should take careful consideration when reviewing their reviews. The purpose of the reviews is to provide constructive criticism or praise for a guide. Reviews that do not offer meaningful input on a tutoring session should be reported.","title":"When to Report a Review"},{"location":"user/searching-booking/","text":"Searching and Booking Sessions with Tutors \u00b6 When searching for tutors, you are able to search either by course subject or by the specific tutor you would like to go to. When you click the search bar, a drop down with those options will appear and then you can choose from them and search in whichever way you would like. What happens after I book a session? \u00b6 After you have searched for the specific tutor and found the session you want to book, it will automatically create a google calendar item in your google calendar with the times you booked as well as any information involving that specific booking. It is linked with your student email address so it will be on your google calendar associated with your student email. Once your time is approaching, you will get a notification saying that you have an upcoming appointment just like you would get any other notification on your mobile device.","title":"Searching and Booking Tutors"},{"location":"user/searching-booking/#searching-and-booking-sessions-with-tutors","text":"When searching for tutors, you are able to search either by course subject or by the specific tutor you would like to go to. When you click the search bar, a drop down with those options will appear and then you can choose from them and search in whichever way you would like.","title":"Searching and Booking Sessions with Tutors"},{"location":"user/searching-booking/#what-happens-after-i-book-a-session","text":"After you have searched for the specific tutor and found the session you want to book, it will automatically create a google calendar item in your google calendar with the times you booked as well as any information involving that specific booking. It is linked with your student email address so it will be on your google calendar associated with your student email. Once your time is approaching, you will get a notification saying that you have an upcoming appointment just like you would get any other notification on your mobile device.","title":"What happens after I book a session?"}]}